/**
 * Git hook installer
 */

import { execSync } from 'node:child_process';
import {
  chmodSync,
  existsSync,
  mkdirSync,
  readFileSync,
  unlinkSync,
  writeFileSync,
} from 'node:fs';
import { join } from 'node:path';
import type {
  HookStatus,
  InstallOptions,
  InstallResult,
  THookName,
  UninstallOptions,
  UninstallResult,
} from '../types';

/**
 * Installs and manages git hooks for Kodebase
 */
export class HookInstaller {
  private readonly hooks: THookName[] = [
    'post-checkout',
    'pre-commit',
    'pre-push',
    'post-merge',
  ];
  private readonly kodebaseMarker = '# Generated by @kodebase/git-ops';

  /**
   * Install git hooks
   */
  async install(options: InstallOptions): Promise<InstallResult> {
    const result: InstallResult = {
      success: false,
      installed: [],
      skipped: [],
      backups: [],
      warnings: [],
      error: undefined,
    };

    try {
      // Validate git repository
      const gitDir = join(options.repoPath, '.git');
      if (!existsSync(gitDir)) {
        result.error = `${options.repoPath} is not a git repository`;
        return result;
      }

      // Check core.hooksPath
      const hooksPath = this.getHooksPath(options.repoPath);
      if (hooksPath && hooksPath !== 'true') {
        result.warnings.push(`core.hooksPath is set to ${hooksPath}`);
      }

      // Create hooks directory if needed
      const hooksDir = join(gitDir, 'hooks');
      if (!existsSync(hooksDir)) {
        mkdirSync(hooksDir, { recursive: true });
      }

      // Install selected hooks
      const hooksToInstall = options.hooks || this.hooks;
      for (const hookName of hooksToInstall) {
        const hookPath = join(hooksDir, hookName);

        // Check if hook already exists
        if (existsSync(hookPath)) {
          const content = readFileSync(hookPath, 'utf-8');

          if (content.includes(this.kodebaseMarker)) {
            result.skipped.push(hookName);
            result.warnings.push(`${hookName} hook already installed`);
            continue;
          }

          // Backup existing hook
          const backupPath = `${hookPath}.backup.${Date.now()}`;
          writeFileSync(backupPath, content);
          result.backups.push(backupPath);
        }

        // Write hook file
        const hookContent = this.generateHookContent(hookName);
        writeFileSync(hookPath, hookContent);
        chmodSync(hookPath, 0o755);
        result.installed.push(hookName);
      }

      result.success = true;
    } catch (error) {
      result.error = error instanceof Error ? error.message : 'Unknown error';
    }

    return result;
  }

  /**
   * Uninstall git hooks
   */
  async uninstall(options: UninstallOptions): Promise<UninstallResult> {
    const result: UninstallResult = {
      success: false,
      uninstalled: [],
      skipped: [],
      restored: [],
      notFound: [],
      warnings: [],
      error: undefined,
    };

    try {
      const gitDir = join(options.repoPath, '.git');
      if (!existsSync(gitDir)) {
        result.error = `${options.repoPath} is not a git repository`;
        return result;
      }

      const hooksDir = join(gitDir, 'hooks');
      const hooksToUninstall = options.hooks || this.hooks;

      for (const hookName of hooksToUninstall) {
        const hookPath = join(hooksDir, hookName);

        // Check if hook exists
        if (!existsSync(hookPath)) {
          result.notFound.push(hookName);
          continue;
        }

        // Check if it's a kodebase hook
        const content = readFileSync(hookPath, 'utf-8');
        if (!content.includes(this.kodebaseMarker)) {
          result.skipped.push(hookName);
          result.warnings.push(`${hookName} is not a kodebase hook`);
          continue;
        }

        // Remove hook
        unlinkSync(hookPath);
        result.uninstalled.push(hookName);

        // Restore backup if requested
        if (options.restoreBackups) {
          const backupPath = this.findLatestBackup(hooksDir, hookName);
          if (backupPath && existsSync(backupPath)) {
            const backupContent = readFileSync(backupPath, 'utf-8');
            writeFileSync(hookPath, backupContent);
            chmodSync(hookPath, 0o755);
            result.restored.push(hookName);
          }
        }
      }

      result.success = true;
    } catch (error) {
      result.error = error instanceof Error ? error.message : 'Unknown error';
    }

    return result;
  }

  /**
   * Get status of all hooks
   */
  async status(repoPath: string): Promise<HookStatus[]> {
    const statuses: HookStatus[] = [];
    const gitDir = join(repoPath, '.git');

    if (!existsSync(gitDir)) {
      return statuses;
    }

    const hooksDir = join(gitDir, 'hooks');

    for (const hookName of this.hooks) {
      const hookPath = join(hooksDir, hookName);
      const exists = existsSync(hookPath);
      let isKodebase = false;

      if (exists) {
        const content = readFileSync(hookPath, 'utf-8');
        isKodebase = content.includes(this.kodebaseMarker);
      }

      statuses.push({
        name: hookName,
        installed: exists,
        isKodebase,
        path: hookPath,
      });
    }

    return statuses;
  }

  /**
   * Get git hooks path configuration
   */
  private getHooksPath(repoPath: string): string {
    try {
      return execSync('git config core.hooksPath || echo "true"', {
        cwd: repoPath,
        encoding: 'utf-8',
      }).trim();
    } catch {
      return 'true';
    }
  }

  /**
   * Generate hook content
   */
  private generateHookContent(hookName: THookName): string {
    return `#!/bin/bash
${this.kodebaseMarker}
# DO NOT EDIT - This file is managed by @kodebase/git-ops

# Run the kodebase git-ops hook
npx @kodebase/git-ops run ${hookName} "$@"
`;
  }

  /**
   * Find latest backup file
   */
  private findLatestBackup(hooksDir: string, hookName: string): string | null {
    try {
      const files = execSync(
        `ls -1 ${hookName}.backup.* 2>/dev/null | sort -r | head -1`,
        {
          cwd: hooksDir,
          encoding: 'utf-8',
        },
      ).trim();

      return files ? join(hooksDir, files) : null;
    } catch {
      return null;
    }
  }
}
