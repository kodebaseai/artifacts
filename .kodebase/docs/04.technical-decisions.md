# Technology Decisions

## Why YAML Over JSON?

**Human Readability**: YAML is more readable in Git diffs and direct editing
**Comments**: Support for documentation within artifact files
**Flexibility**: Easier to extend schemas without breaking existing files
**Git-Friendly**: Better merge conflict resolution than JSON

## Why MCP Over Custom Protocol?

**Standardization**: Vendor-neutral protocol supported by major AI providers
**Future-Proof**: Evolves with AI ecosystem rather than custom solution
**Interoperability**: Multiple AI assistants can connect simultaneously
**Simplicity**: Well-defined protocol reduces implementation complexity

## Why Pure Git-Native Storage Strategy?

**Single Source of Truth**: Git is the only persistent storage, eliminating sync complexity
**Zero Infrastructure**: No database to manage, backup, or migrate for core functionality
**Perfect CLI/Web Sync**: Both interfaces see identical data through Git
**Offline-First**: CLI works completely offline, web interface degrades gracefully
**GitHub API for Web Interface**: Web interface uses GitHub API to access `.kodebase/` artifacts in repositories (CLI uses direct file system). 5,000 requests/hour per user sufficient with intelligent caching for team collaboration and multi-repo dashboards
**Clear Upgrade Path**: Add selective database features only when proven necessary at scale

*Decision based on [Data Storage Strategy Spike](../engineering/spikes/data-storage-strategy.md)*
*Implementation: Issues A.1.x (core architecture), B.1.x (CLI file operations)*

## Why NextAuth for Authentication?

**GitHub Integration**: Native GitHub provider with excellent OAuth flow
**Session Management**: Built-in JWT and database session handling
**Type Safety**: Full TypeScript support with Next.js integration
**Ecosystem**: Mature library with extensive documentation and community

*Implementation: Initiative C (web interface authentication), Milestone C.1 (MCP server integration)*

## Why Next.js App Router for Web Interface?

**Server Components**: Optimal for GitHub API calls with server-side rendering
**File-based Routing**: Clean organization for dashboard, repositories, and issue views
**Built-in Optimization**: Image optimization, bundle splitting, and performance features
**TypeScript Integration**: Excellent developer experience with full type safety

*Implementation: Initiative C (web interface), Milestone C.2 (comprehensive context integration)*

## Why Redis for GitHub API Caching?

**Performance**: Sub-millisecond response times for cached GitHub API responses
**TTL Support**: Built-in expiration for cache invalidation strategies
**Scalability**: Handles high-frequency API response caching efficiently
**Managed Options**: Available as managed service (Upstash, Redis Cloud) for easy deployment

## Why Node.js for CLI Implementation?

**Ecosystem Alignment**: Shared TypeScript codebase with web interface via Turborepo
**npm Distribution**: Native package manager integration for easy installation
**Cross-platform**: Consistent behavior across Windows, macOS, and Linux
**Developer Velocity**: Faster iteration during initial development phase

## Why Hybrid Backend Architecture?

**Serverless for GitHub API**: Functions optimal for GitHub proxy with auto-scaling and caching
**Persistent for Real-time**: WebSocket server needed for collaboration and MCP session management
**Phased Implementation**: Start pure serverless MVP, add persistent layer when real-time features required
**Cost Efficiency**: Each layer scales independently based on actual usage patterns
**Development Velocity**: Serverless enables rapid MVP while persistent server handles complex state

*Decision based on [Backend Architecture Spike](../engineering/spikes/backend-architecture.md)*
*Implementation: Initiative B (CLI development), Initiative C (MCP integration)*

## Why Vercel for Deployment Platform?

**Next.js Optimization**: Native platform with optimal performance for App Router
**GitHub Integration**: Seamless deployment with automatic preview environments
**Serverless Functions**: Perfect for GitHub API proxy with auto-scaling
**Developer Experience**: Zero-config deployment with excellent debugging tools
**Migration Path**: Clear upgrade to Fly.io when Redis performance becomes critical

*Decision based on [Deployment Platform Spike](../engineering/spikes/deployment-platform.md)*
*Implementation: Initiative B (CLI distribution), Initiative C (web interface deployment)*

## Why Both Embedded and Standalone MCP Server?

**CLI Integration**: Embedded MCP server for local development workflow
**Web Interface**: Standalone MCP server for team collaboration features
**Deployment Flexibility**: Choose appropriate mode based on usage pattern
**Development Experience**: Embedded mode enables offline-first CLI functionality

## Why Hybrid Changelog System?

**Methodology Evolution Tracking**: Document process improvements and learnings from self-development
**Multi-Audience Communication**: Internal team coordination and external user feature announcements
**Issue Lifecycle Integration**: Automated collection from issue completion with human editorial control
**AI Context Enhancement**: Provide project evolution history for better AI assistant understanding
**Self-Validation**: Track our own methodology improvements while building Kodebase

*Decision based on [Changelog System Spike](../engineering/spikes/changelog-system.md)*
*Implementation: Issue A.2.5 (methodology review process), Initiative C (automated changelog)*

## Why Turborepo for Monorepo Management?

**Multiple Packages**: CLI, web interface, MCP server, and shared libraries need coordinated development
**Build Optimization**: Intelligent caching and parallel builds for faster development cycles
**Shared Dependencies**: Types, schemas, and validation logic used across multiple packages
**Developer Experience**: Single command to run all dev servers and build only changed packages

## Why Draft PRs for Team Coordination?

**Git-Native Visibility**: Leverages existing Git workflow without additional tooling
**Immediate Team Awareness**: Draft PR creation provides instant visibility into active work
**Zero Learning Curve**: Developers already know Git and PR workflows
**Automatic Backup**: Issue branches are immediately pushed and backed up
**Natural Collaboration**: PR comments enable async discussion and help requests
**Standard Workflow**: Works with any Git hosting platform (GitHub, GitLab, etc.)

**Pattern**: Create issue branch → immediate empty commit → push → draft PR → regular development
**Benefits**: Solves issue branch visibility problem without breaking isolated development model
